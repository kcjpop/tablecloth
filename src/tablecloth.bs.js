// Generated by BUCKLESCRIPT VERSION 6.0.0-dev.1, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_Result = require("bs-platform/lib/js/belt_Result.js");
var Belt_SetInt = require("bs-platform/lib/js/belt_SetInt.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function $less$pipe(a, b) {
  return Curry._1(a, b);
}

function $great$great(f1, f2, x) {
  return Curry._1(f2, Curry._1(f1, x));
}

function $less$less(f1, f2, x) {
  return Curry._1(f1, Curry._1(f2, x));
}

function identity(value) {
  return value;
}

var empty = /* array */[];

function singleton(a) {
  return /* array */[a];
}

function length(a) {
  return a.length;
}

function isEmpty(a) {
  return a.length === 0;
}

var initialize = Belt_Array.makeBy;

var repeat = Belt_Array.make;

function range($staropt$star, to_) {
  var from = $staropt$star !== undefined ? $staropt$star : 0;
  return Belt_Array.makeBy(to_ - from | 0, (function (i) {
                return i + from | 0;
              }));
}

var fromList = Belt_List.toArray;

var toList = Belt_List.fromArray;

function toIndexedList(array) {
  return Belt_Array.reduceReverse(array, /* tuple */[
                array.length - 1 | 0,
                /* [] */0
              ], (function (param, x) {
                  var i = param[0];
                  return /* tuple */[
                          i - 1 | 0,
                          /* :: */Block.simpleVariant("::", [
                              /* tuple */[
                                i,
                                x
                              ],
                              param[1]
                            ])
                        ];
                }))[1];
}

function get(index, array) {
  return Belt_Array.get(array, index);
}

function set(index, value, array) {
  return Caml_array.caml_array_set(array, index, value);
}

function sum(a) {
  return Belt_Array.reduce(a, 0, (function (prim, prim$1) {
                return prim + prim$1 | 0;
              }));
}

function floatSum(a) {
  return Belt_Array.reduce(a, 0.0, (function (prim, prim$1) {
                return prim + prim$1;
              }));
}

function filter(f, a) {
  return Belt_Array.keep(a, f);
}

function map(f, a) {
  return Belt_Array.map(a, f);
}

function mapWithIndex(f, a) {
  return Belt_Array.mapWithIndex(a, f);
}

function map2(f, a, b) {
  return Belt_Array.zipBy(a, b, f);
}

function map3(f, arrayA, arrayB, arrayC) {
  var minLength = Belt_Array.reduce(/* array */[
        arrayB.length,
        arrayC.length
      ], arrayA.length, (function (prim, prim$1) {
          if (prim < prim$1) {
            return prim;
          } else {
            return prim$1;
          }
        }));
  return Belt_Array.makeBy(minLength, (function (i) {
                return Curry._3(f, Caml_array.caml_array_get(arrayA, i), Caml_array.caml_array_get(arrayB, i), Caml_array.caml_array_get(arrayC, i));
              }));
}

function flatMap(f, a) {
  return Belt_Array.concatMany(Belt_Array.map(a, f));
}

function find(f, array) {
  var array$1 = array;
  var f$1 = f;
  var length = array.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= length) {
      return undefined;
    } else if (Curry._1(f$1, Caml_array.caml_array_get(array$1, i))) {
      return Caml_option.some(Caml_array.caml_array_get(array$1, i));
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function any(f, a) {
  return Belt_Array.some(a, f);
}

function all(f, a) {
  return Belt_Array.every(a, f);
}

var append = Belt_Array.concat;

var concatenate = Belt_Array.concatMany;

function intersperse(sep, array) {
  return Belt_Array.makeBy(Caml_primitive.caml_int_max(0, (array.length << 1) - 1 | 0), (function (i) {
                if (i % 2 !== 0) {
                  return sep;
                } else {
                  return Caml_array.caml_array_get(array, i / 2 | 0);
                }
              }));
}

function slice(from, to_, array) {
  var defaultTo = to_ !== undefined ? to_ : array.length;
  var sliceFrom = from >= 0 ? Caml_primitive.caml_int_min(array.length, from) : Caml_primitive.caml_int_max(0, Caml_primitive.caml_int_min(array.length, array.length + from | 0));
  var sliceTo = defaultTo >= 0 ? Caml_primitive.caml_int_min(array.length, defaultTo) : Caml_primitive.caml_int_max(0, Caml_primitive.caml_int_min(array.length, array.length + defaultTo | 0));
  if (sliceFrom >= sliceTo) {
    return empty;
  } else {
    return Belt_Array.makeBy(sliceTo - sliceFrom | 0, (function (i) {
                  return Caml_array.caml_array_get(array, i + sliceFrom | 0);
                }));
  }
}

function foldLeft(f, initial, a) {
  return Belt_Array.reduce(a, initial, (function (param, param$1) {
                return Curry._2(f, param$1, param);
              }));
}

function foldRight(f, initial, a) {
  return Belt_Array.reduceReverse(a, initial, (function (param, param$1) {
                return Curry._2(f, param$1, param);
              }));
}

var reverse = Belt_Array.reverse;

var reverseInPlace = Belt_Array.reverseInPlace;

function forEach(f, a) {
  return Belt_Array.forEach(a, f);
}

var $$Array = /* module */Block.localModule([
    "empty",
    "singleton",
    "length",
    "isEmpty",
    "is_empty",
    "initialize",
    "repeat",
    "range",
    "fromList",
    "from_list",
    "toList",
    "to_list",
    "toIndexedList",
    "to_indexed_list",
    "get",
    "set",
    "sum",
    "floatSum",
    "float_sum",
    "filter",
    "map",
    "mapWithIndex",
    "map_with_index",
    "mapi",
    "map2",
    "map3",
    "flatMap",
    "flat_map",
    "find",
    "any",
    "all",
    "append",
    "concatenate",
    "intersperse",
    "slice",
    "foldLeft",
    "fold_left",
    "foldRight",
    "fold_right",
    "reverse",
    "reverseInPlace",
    "reverse_in_place",
    "forEach",
    "for_each"
  ], [
    empty,
    singleton,
    length,
    isEmpty,
    isEmpty,
    initialize,
    repeat,
    range,
    fromList,
    fromList,
    toList,
    toList,
    toIndexedList,
    toIndexedList,
    get,
    set,
    sum,
    floatSum,
    floatSum,
    filter,
    map,
    mapWithIndex,
    mapWithIndex,
    mapWithIndex,
    map2,
    map3,
    flatMap,
    flatMap,
    find,
    any,
    all,
    append,
    concatenate,
    intersperse,
    slice,
    foldLeft,
    foldLeft,
    foldRight,
    foldRight,
    reverse,
    reverseInPlace,
    reverseInPlace,
    forEach,
    forEach
  ]);

var reverse$1 = Belt_List.reverse;

function sum$1(l) {
  return Belt_List.reduce(l, 0, (function (prim, prim$1) {
                return prim + prim$1 | 0;
              }));
}

function floatSum$1(l) {
  return Belt_List.reduce(l, 0.0, (function (prim, prim$1) {
                return prim + prim$1;
              }));
}

function map$1(f, l) {
  return Belt_List.map(l, f);
}

function indexedMap(f, l) {
  return Belt_List.mapWithIndex(l, f);
}

function map2$1(f, a, b) {
  return Belt_List.zipBy(a, b, f);
}

function getBy(f, l) {
  return Belt_List.getBy(l, f);
}

function elemIndex(value, l) {
  var index = Belt_List.toArray(l).findIndex((function (param) {
          return Caml_obj.caml_equal(value, param);
        }));
  if (index !== -1) {
    return index;
  }
  
}

function last(_l) {
  while(true) {
    var l = _l;
    if (l) {
      var tail = l[1];
      if (tail) {
        _l = tail;
        continue ;
      } else {
        return Caml_option.some(l[0]);
      }
    } else {
      return undefined;
    }
  };
}

function member(value, l) {
  return Belt_List.has(l, value, Caml_obj.caml_equal);
}

function uniqueBy(f, l) {
  var f$1 = f;
  var _existing = Belt_SetString.empty;
  var _remaining = l;
  var _accumulator = /* [] */0;
  while(true) {
    var accumulator = _accumulator;
    var remaining = _remaining;
    var existing = _existing;
    if (remaining) {
      var rest = remaining[1];
      var first = remaining[0];
      var computedFirst = Curry._1(f$1, first);
      if (Belt_SetString.has(existing, computedFirst)) {
        _remaining = rest;
        continue ;
      } else {
        _accumulator = /* :: */Block.simpleVariant("::", [
            first,
            accumulator
          ]);
        _remaining = rest;
        _existing = Belt_SetString.add(existing, computedFirst);
        continue ;
      }
    } else {
      return Belt_List.reverse(accumulator);
    }
  };
}

function find$1(f, l) {
  return Belt_List.getBy(l, f);
}

function getAt(index, l) {
  return Belt_List.get(l, index);
}

var any$1 = List.exists;

var head = Belt_List.head;

function drop(count, l) {
  return Belt_Option.getWithDefault(Belt_List.drop(l, count), /* [] */0);
}

function init(l) {
  var match = Belt_List.reverse(l);
  if (match) {
    return Belt_List.reverse(match[1]);
  }
  
}

function filterMap(f, l) {
  return Belt_List.keepMap(l, f);
}

function filter$1(f, l) {
  return Belt_List.keep(l, f);
}

function concat(ls) {
  return Belt_List.concatMany(Belt_List.toArray(ls));
}

function partition(f, l) {
  return Belt_List.partition(l, f);
}

function foldr(f, init, l) {
  return List.fold_right(f, l, init);
}

function foldl(f, init, l) {
  return List.fold_right(f, Belt_List.reverse(l), init);
}

function findIndexHelp(_index, predicate, _l) {
  while(true) {
    var l = _l;
    var index = _index;
    if (l) {
      if (Curry._1(predicate, l[0])) {
        return index;
      } else {
        _l = l[1];
        _index = index + 1 | 0;
        continue ;
      }
    } else {
      return undefined;
    }
  };
}

function findIndex(f, l) {
  return findIndexHelp(0, f, l);
}

function take(count, l) {
  return Belt_Option.getWithDefault(Belt_List.take(l, count), /* [] */0);
}

function updateAt(index, f, l) {
  if (index < 0) {
    return l;
  } else {
    var head = take(index, l);
    var tail = drop(index, l);
    if (tail) {
      return Pervasives.$at(head, /* :: */Block.simpleVariant("::", [
                    Curry._1(f, tail[0]),
                    tail[1]
                  ]));
    } else {
      return l;
    }
  }
}

var length$1 = List.length;

function dropWhile(f, _l) {
  while(true) {
    var l = _l;
    if (l) {
      if (Curry._1(f, l[0])) {
        _l = l[1];
        continue ;
      } else {
        return l;
      }
    } else {
      return /* [] */0;
    }
  };
}

function isEmpty$1(l) {
  return l === /* [] */0;
}

function cons(item, l) {
  return /* :: */Block.simpleVariant("::", [
            item,
            l
          ]);
}

function takeWhile(f, l) {
  var _memo = /* [] */0;
  var _list = l;
  while(true) {
    var list = _list;
    var memo = _memo;
    if (list) {
      var x = list[0];
      if (Curry._1(f, x)) {
        _list = list[1];
        _memo = /* :: */Block.simpleVariant("::", [
            x,
            memo
          ]);
        continue ;
      } else {
        return Belt_List.reverse(memo);
      }
    } else {
      return Belt_List.reverse(memo);
    }
  };
}

function all$1(f, l) {
  return Belt_List.every(l, f);
}

function tail(l) {
  if (l) {
    return l[1];
  }
  
}

var append$1 = Pervasives.$at;

function removeAt(index, l) {
  if (index < 0) {
    return l;
  } else {
    var head = take(index, l);
    var tail$1 = tail(drop(index, l));
    if (tail$1 !== undefined) {
      return Pervasives.$at(head, tail$1);
    } else {
      return l;
    }
  }
}

function minimumBy(f, ls) {
  var minBy = function (x, param) {
    var fy = param[1];
    var fx = Curry._1(f, x);
    if (Caml_obj.caml_lessthan(fx, fy)) {
      return /* tuple */[
              x,
              fx
            ];
    } else {
      return /* tuple */[
              param[0],
              fy
            ];
    }
  };
  if (ls) {
    var lrest = ls[1];
    var l = ls[0];
    if (lrest) {
      return Caml_option.some(foldl(minBy, /* tuple */[
                        l,
                        Curry._1(f, l)
                      ], lrest)[0]);
    } else {
      return Caml_option.some(l);
    }
  }
  
}

function minimum(l) {
  if (l) {
    return Caml_option.some(foldl(Caml_obj.caml_min, l[0], l[1]));
  }
  
}

function maximumBy(f, ls) {
  var maxBy = function (x, param) {
    var fy = param[1];
    var fx = Curry._1(f, x);
    if (Caml_obj.caml_greaterthan(fx, fy)) {
      return /* tuple */[
              x,
              fx
            ];
    } else {
      return /* tuple */[
              param[0],
              fy
            ];
    }
  };
  if (ls) {
    var ls_ = ls[1];
    var l_ = ls[0];
    if (ls_) {
      return Caml_option.some(foldl(maxBy, /* tuple */[
                        l_,
                        Curry._1(f, l_)
                      ], ls_)[0]);
    } else {
      return Caml_option.some(l_);
    }
  }
  
}

function maximum(l) {
  if (l) {
    return Caml_option.some(foldl(Caml_obj.caml_max, l[0], l[1]));
  }
  
}

function sortBy(f, l) {
  return Belt_List.sort(l, (function (a, b) {
                var a$prime = Curry._1(f, a);
                var b$prime = Curry._1(f, b);
                if (Caml_obj.caml_equal(a$prime, b$prime)) {
                  return 0;
                } else if (Caml_obj.caml_lessthan(a$prime, b$prime)) {
                  return -1;
                } else {
                  return 1;
                }
              }));
}

function span(f, xs) {
  return /* tuple */[
          takeWhile(f, xs),
          dropWhile(f, xs)
        ];
}

function groupWhile(f, xs) {
  if (xs) {
    var x = xs[0];
    var match = span(Curry._1(f, x), xs[1]);
    return /* :: */Block.simpleVariant("::", [
              /* :: */Block.simpleVariant("::", [
                  x,
                  match[0]
                ]),
              groupWhile(f, match[1])
            ]);
  } else {
    return /* [] */0;
  }
}

function splitAt(index, xs) {
  return /* tuple */[
          take(index, xs),
          drop(index, xs)
        ];
}

function insertAt(index, value, xs) {
  return Pervasives.$at(take(index, xs), /* :: */Block.simpleVariant("::", [
                value,
                drop(index, xs)
              ]));
}

function splitWhen(f, l) {
  var match = findIndexHelp(0, f, l);
  if (match !== undefined) {
    return splitAt(match, l);
  } else {
    return /* tuple */[
            l,
            /* [] */0
          ];
  }
}

function intersperse$1(sep, xs) {
  if (xs) {
    var step = function (x, rest) {
      return /* :: */Block.simpleVariant("::", [
                sep,
                /* :: */Block.simpleVariant("::", [
                    x,
                    rest
                  ])
              ]);
    };
    var spersed = List.fold_right(step, xs[1], /* [] */0);
    return /* :: */Block.simpleVariant("::", [
              xs[0],
              spersed
            ]);
  } else {
    return /* [] */0;
  }
}

function initialize$1(n, f) {
  var _i = n - 1 | 0;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var i = _i;
    if (i < 0) {
      return acc;
    } else {
      _acc = /* :: */Block.simpleVariant("::", [
          Curry._1(f, i),
          acc
        ]);
      _i = i - 1 | 0;
      continue ;
    }
  };
}

function sortWith(f, l) {
  return Belt_List.sort(l, f);
}

function iter(f, l) {
  return Belt_List.forEach(l, f);
}

function withDefault($$default, r) {
  return Belt_Result.getWithDefault(r, $$default);
}

function map2$2(f, a, b) {
  if (a.tag) {
    return /* Error */Block.variant("Error", 1, [a[0]]);
  } else if (b.tag) {
    return /* Error */Block.variant("Error", 1, [b[0]]);
  } else {
    return /* Ok */Block.variant("Ok", 0, [Curry._2(f, a[0], b[0])]);
  }
}

function combine(l) {
  var f = function (param, param$1) {
    return map2$2((function (a, b) {
                  return /* :: */Block.simpleVariant("::", [
                            a,
                            b
                          ]);
                }), param, param$1);
  };
  return List.fold_right(f, l, /* Ok */Block.variant("Ok", 0, [/* [] */0]));
}

function map$2(f, r) {
  return Belt_Result.map(r, f);
}

function toOption(r) {
  if (r.tag) {
    return undefined;
  } else {
    return Caml_option.some(r[0]);
  }
}

function andThen(f, r) {
  return Belt_Result.flatMap(r, f);
}

function pp(errf, okf, fmt, r) {
  if (r.tag) {
    Format.pp_print_string(fmt, "<error: ");
    Curry._2(errf, fmt, r[0]);
    return Format.pp_print_string(fmt, ">");
  } else {
    Format.pp_print_string(fmt, "<ok: ");
    Curry._2(okf, fmt, r[0]);
    return Format.pp_print_string(fmt, ">");
  }
}

var Result = /* module */Block.localModule([
    "withDefault",
    "with_default",
    "map2",
    "combine",
    "map",
    "toOption",
    "to_option",
    "andThen",
    "and_then",
    "pp"
  ], [
    withDefault,
    withDefault,
    map2$2,
    combine,
    map$2,
    toOption,
    toOption,
    andThen,
    andThen,
    pp
  ]);

function andThen$1(f, o) {
  if (o !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(o));
  }
  
}

function or_(ma, mb) {
  if (ma !== undefined) {
    return ma;
  } else {
    return mb;
  }
}

function orElse(ma, mb) {
  if (mb !== undefined) {
    return mb;
  } else {
    return ma;
  }
}

function map$3(f, o) {
  return Belt_Option.map(o, f);
}

function withDefault$1($$default, o) {
  return Belt_Option.getWithDefault(o, $$default);
}

function values(l) {
  var valuesHelper = function (item, l) {
    if (item !== undefined) {
      return /* :: */Block.simpleVariant("::", [
                Caml_option.valFromOption(item),
                l
              ]);
    } else {
      return l;
    }
  };
  return List.fold_right(valuesHelper, l, /* [] */0);
}

function toList$1(o) {
  if (o !== undefined) {
    return /* :: */Block.simpleVariant("::", [
              Caml_option.valFromOption(o),
              /* [] */0
            ]);
  } else {
    return /* [] */0;
  }
}

function toOption$1(sentinel, value) {
  if (Caml_obj.caml_equal(value, sentinel)) {
    return undefined;
  } else {
    return Caml_option.some(value);
  }
}

var $$Option = /* module */Block.localModule([
    "andThen",
    "and_then",
    "or_",
    "orElse",
    "or_else",
    "map",
    "withDefault",
    "with_default",
    "values",
    "toList",
    "to_list",
    "isSome",
    "is_some",
    "toOption",
    "to_option"
  ], [
    andThen$1,
    andThen$1,
    or_,
    orElse,
    orElse,
    map$3,
    withDefault$1,
    withDefault$1,
    values,
    toList$1,
    toList$1,
    Belt_Option.isSome,
    Belt_Option.isSome,
    toOption$1,
    toOption$1
  ]);

function toCode(c) {
  return c;
}

function fromCode(i) {
  if (0 <= i && i <= 255) {
    return Char.chr(i);
  }
  
}

function toString(c) {
  return $$String.make(1, c);
}

function fromString(str) {
  var match = str.length;
  if (match !== 1) {
    return undefined;
  } else {
    return Caml_string.get(str, 0);
  }
}

function toDigit($$char) {
  if ($$char > 57 || $$char < 48) {
    return undefined;
  } else {
    return $$char - /* "0" */48 | 0;
  }
}

function toLowercase($$char) {
  if ($$char > 90 || $$char < 65) {
    return $$char;
  } else {
    return Char.chr(/* "a" */97 + ($$char - /* "A" */65 | 0) | 0);
  }
}

function toUppercase($$char) {
  if ($$char > 122 || $$char < 97) {
    return $$char;
  } else {
    return Char.chr(/* "A" */65 + ($$char - /* "a" */97 | 0) | 0);
  }
}

function isLowercase(param) {
  return !(param > 122 || param < 97);
}

function isUppercase(param) {
  return !(param > 90 || param < 65);
}

function isLetter(param) {
  if (param >= 91) {
    return !(param > 122 || param < 97);
  } else {
    return param >= 65;
  }
}

function isDigit(param) {
  return !(param > 57 || param < 48);
}

function isAlphanumeric(param) {
  var switcher = param - 48 | 0;
  if (switcher > 42 || switcher < 0) {
    return !(switcher > 74 || switcher < 49);
  } else {
    return switcher > 16 || switcher < 10;
  }
}

function isPrintable(param) {
  return !(param > 126 || param < 32);
}

function isWhitespace(param) {
  if (param >= 14) {
    return param === 32;
  } else {
    return param >= 9;
  }
}

var Char$1 = /* module */Block.localModule([
    "toCode",
    "to_code",
    "fromCode",
    "from_code",
    "toString",
    "to_string",
    "fromString",
    "from_string",
    "toDigit",
    "to_digit",
    "toLowercase",
    "to_lowercase",
    "toUppercase",
    "to_uppercase",
    "isLowercase",
    "is_lowercase",
    "isUppercase",
    "is_uppercase",
    "isLetter",
    "is_letter",
    "isDigit",
    "is_digit",
    "isAlphanumeric",
    "is_alphanumeric",
    "isPrintable",
    "is_printable",
    "isWhitespace",
    "is_whitespace"
  ], [
    toCode,
    toCode,
    fromCode,
    fromCode,
    toString,
    toString,
    fromString,
    fromString,
    toDigit,
    toDigit,
    toLowercase,
    toLowercase,
    toUppercase,
    toUppercase,
    isLowercase,
    isLowercase,
    isUppercase,
    isUppercase,
    isLetter,
    isLetter,
    isDigit,
    isDigit,
    isAlphanumeric,
    isAlphanumeric,
    isPrintable,
    isPrintable,
    isWhitespace,
    isWhitespace
  ]);

function negate(prim) {
  return -prim | 0;
}

function isEven(n) {
  return n % 2 === 0;
}

function isOdd(n) {
  return n % 2 !== 0;
}

var Int = /* module */Block.localModule([
    "negate",
    "isEven",
    "is_even",
    "isOdd",
    "is_odd"
  ], [
    negate,
    isEven,
    isEven,
    isOdd,
    isOdd
  ]);

function create(a, b) {
  return /* tuple */[
          a,
          b
        ];
}

function first(param) {
  return param[0];
}

function second(param) {
  return param[1];
}

function mapFirst(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1]
        ];
}

function mapSecond(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1])
        ];
}

function mapEach(f, g, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          Curry._1(g, param[1])
        ];
}

function mapAll(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          Curry._1(f, param[1])
        ];
}

function swap(param) {
  return /* tuple */[
          param[1],
          param[0]
        ];
}

function curry(f, a, b) {
  return Curry._1(f, /* tuple */[
              a,
              b
            ]);
}

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function toList$2(param) {
  return /* :: */Block.simpleVariant("::", [
            param[0],
            /* :: */Block.simpleVariant("::", [
                param[1],
                /* [] */0
              ])
          ]);
}

var Tuple2 = /* module */Block.localModule([
    "create",
    "first",
    "second",
    "mapFirst",
    "map_first",
    "mapSecond",
    "map_second",
    "mapEach",
    "map_each",
    "mapAll",
    "map_all",
    "swap",
    "curry",
    "uncurry",
    "toList",
    "to_list"
  ], [
    create,
    first,
    second,
    mapFirst,
    mapFirst,
    mapSecond,
    mapSecond,
    mapEach,
    mapEach,
    mapAll,
    mapAll,
    swap,
    curry,
    uncurry,
    toList$2,
    toList$2
  ]);

function create$1(a, b, c) {
  return /* tuple */[
          a,
          b,
          c
        ];
}

function first$1(param) {
  return param[0];
}

function second$1(param) {
  return param[1];
}

function third(param) {
  return param[2];
}

function init$1(param) {
  return /* tuple */[
          param[0],
          param[1]
        ];
}

function tail$1(param) {
  return /* tuple */[
          param[1],
          param[2]
        ];
}

function mapFirst$1(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          param[1],
          param[2]
        ];
}

function mapSecond$1(f, param) {
  return /* tuple */[
          param[0],
          Curry._1(f, param[1]),
          param[2]
        ];
}

function mapThird(f, param) {
  return /* tuple */[
          param[0],
          param[1],
          Curry._1(f, param[2])
        ];
}

function mapEach$1(f, g, h, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          Curry._1(g, param[1]),
          Curry._1(h, param[2])
        ];
}

function mapAll$1(f, param) {
  return /* tuple */[
          Curry._1(f, param[0]),
          Curry._1(f, param[1]),
          Curry._1(f, param[2])
        ];
}

function rotateLeft(param) {
  return /* tuple */[
          param[1],
          param[2],
          param[0]
        ];
}

function rotateRight(param) {
  return /* tuple */[
          param[2],
          param[0],
          param[1]
        ];
}

function curry$1(f, a, b, c) {
  return Curry._1(f, /* tuple */[
              a,
              b,
              c
            ]);
}

function uncurry$1(f, param) {
  return Curry._3(f, param[0], param[1], param[2]);
}

function toList$3(param) {
  return /* :: */Block.simpleVariant("::", [
            param[0],
            /* :: */Block.simpleVariant("::", [
                param[1],
                /* :: */Block.simpleVariant("::", [
                    param[2],
                    /* [] */0
                  ])
              ])
          ]);
}

var Tuple3 = /* module */Block.localModule([
    "create",
    "first",
    "second",
    "third",
    "init",
    "tail",
    "mapFirst",
    "map_first",
    "mapSecond",
    "map_second",
    "mapThird",
    "map_third",
    "mapEach",
    "map_each",
    "mapAll",
    "map_all",
    "rotateLeft",
    "rotate_left",
    "rotateRight",
    "rotate_right",
    "curry",
    "uncurry",
    "toList",
    "to_list"
  ], [
    create$1,
    first$1,
    second$1,
    third,
    init$1,
    tail$1,
    mapFirst$1,
    mapFirst$1,
    mapSecond$1,
    mapSecond$1,
    mapThird,
    mapThird,
    mapEach$1,
    mapEach$1,
    mapAll$1,
    mapAll$1,
    rotateLeft,
    rotateLeft,
    rotateRight,
    rotateRight,
    curry$1,
    uncurry$1,
    toList$3,
    toList$3
  ]);

function length$2(prim) {
  return prim.length;
}

function toInt(s) {
  try {
    return /* Ok */Block.variant("Ok", 0, [Caml_format.caml_int_of_string(s)]);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    return /* Error */Block.variant("Error", 1, [Printexc.to_string(e)]);
  }
}

function toFloat(s) {
  try {
    return /* Ok */Block.variant("Ok", 0, [Caml_format.caml_float_of_string(s)]);
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    return /* Error */Block.variant("Error", 1, [Printexc.to_string(e)]);
  }
}

function uncons(s) {
  if (s === "") {
    return undefined;
  } else {
    return /* tuple */[
            Caml_string.get(s, 0),
            $$String.sub(s, 1, s.length - 1 | 0)
          ];
  }
}

function dropLeft(count, s) {
  return s.substr(count);
}

function dropRight(count, s) {
  if (count < 1) {
    return s;
  } else {
    return s.slice(0, -count | 0);
  }
}

function split(on, s) {
  return Belt_List.fromArray(s.split(on));
}

var join = $$String.concat;

function endsWith(suffix, s) {
  return s.endsWith(suffix);
}

function startsWith(prefix, s) {
  return s.startsWith(prefix);
}

var toLower = $$String.lowercase_ascii;

var toUpper = $$String.uppercase_ascii;

var uncapitalize = $$String.uncapitalize_ascii;

var capitalize = $$String.capitalize_ascii;

function isCapitalized(s) {
  return s === $$String.capitalize_ascii(s);
}

function contains(substring, s) {
  return s.includes(substring);
}

function repeat$1(count, s) {
  return s.repeat(count);
}

function reverse$2(s) {
  return $$String.concat("", Belt_List.fromArray(Array.from(s).reverse()));
}

function fromList$1(l) {
  var l$1 = Belt_List.map(l, toCode);
  return $$String.concat("", Belt_List.map(l$1, (function (prim) {
                    return String.fromCharCode(prim);
                  })));
}

function toList$4(s) {
  return Belt_List.fromArray(Array.from(s));
}

function fromInt(i) {
  return Curry._1(Printf.sprintf(/* Format */Block.simpleVariant("Format", [
                    /* Int */Block.variant("Int", 4, [
                        /* Int_d */0,
                        /* No_padding */0,
                        /* No_precision */0,
                        /* End_of_format */0
                      ]),
                    "%d"
                  ])), i);
}

function concat$1(param) {
  return $$String.concat("", param);
}

function fromChar(c) {
  return String.fromCharCode(c);
}

function slice$1(from, to_, str) {
  return str.slice(from, to_);
}

function trim(prim) {
  return prim.trim();
}

function insertAt$1(insert, index, s) {
  return s.slice(0, index) + (insert + s.slice(index));
}

var $$String$1 = /* module */Block.localModule([
    "length",
    "toInt",
    "to_int",
    "toFloat",
    "to_float",
    "uncons",
    "dropLeft",
    "drop_left",
    "dropRight",
    "drop_right",
    "split",
    "join",
    "endsWith",
    "ends_with",
    "startsWith",
    "starts_with",
    "toLower",
    "to_lower",
    "toUpper",
    "to_upper",
    "uncapitalize",
    "capitalize",
    "isCapitalized",
    "is_capitalized",
    "contains",
    "repeat",
    "reverse",
    "fromList",
    "from_list",
    "toList",
    "to_list",
    "fromInt",
    "from_int",
    "concat",
    "fromChar",
    "from_char",
    "slice",
    "trim",
    "insertAt",
    "insert_at"
  ], [
    length$2,
    toInt,
    toInt,
    toFloat,
    toFloat,
    uncons,
    dropLeft,
    dropLeft,
    dropRight,
    dropRight,
    split,
    join,
    endsWith,
    endsWith,
    startsWith,
    startsWith,
    toLower,
    toLower,
    toUpper,
    toUpper,
    uncapitalize,
    capitalize,
    isCapitalized,
    isCapitalized,
    contains,
    repeat$1,
    reverse$2,
    fromList$1,
    fromList$1,
    toList$4,
    toList$4,
    fromInt,
    fromInt,
    concat$1,
    fromChar,
    fromChar,
    slice$1,
    trim,
    insertAt$1,
    insertAt$1
  ]);

function fromList$2(l) {
  return Belt_SetString.fromArray(Belt_List.toArray(l));
}

function member$1(value, set) {
  return Belt_SetString.has(set, value);
}

var diff = Belt_SetString.diff;

var isEmpty$2 = Belt_SetString.isEmpty;

var toList$5 = Belt_SetString.toList;

function ofList(s) {
  return Belt_SetString.fromArray(Belt_List.toArray(s));
}

function remove(value, set) {
  return Belt_SetString.remove(set, value);
}

function add(value, set) {
  return Belt_SetString.add(set, value);
}

function set$1(value, set$2) {
  return Belt_SetString.add(set$2, value);
}

function pp$1(fmt, set) {
  Format.pp_print_string(fmt, "{ ");
  Belt_SetString.forEach(set, (function (v) {
          Format.pp_print_string(fmt, v);
          return Format.pp_print_string(fmt, ", ");
        }));
  Format.pp_print_string(fmt, " }");
  return /* () */0;
}

function fromList$3(l) {
  return Belt_SetInt.fromArray(Belt_List.toArray(l));
}

function member$2(value, set) {
  return Belt_SetInt.has(set, value);
}

var diff$1 = Belt_SetInt.diff;

var isEmpty$3 = Belt_SetInt.isEmpty;

var toList$6 = Belt_SetInt.toList;

function ofList$1(s) {
  return Belt_SetInt.fromArray(Belt_List.toArray(s));
}

function remove$1(value, set) {
  return Belt_SetInt.remove(set, value);
}

function add$1(value, set) {
  return Belt_SetInt.add(set, value);
}

function set$2(value, set$3) {
  return Belt_SetInt.add(set$3, value);
}

function pp$2(fmt, set) {
  Format.pp_print_string(fmt, "{ ");
  Belt_SetInt.forEach(set, (function (v) {
          Format.pp_print_int(fmt, v);
          return Format.pp_print_string(fmt, ", ");
        }));
  Format.pp_print_string(fmt, " }");
  return /* () */0;
}

function fromList$4(l) {
  return Belt_MapString.fromArray(Belt_List.toArray(l));
}

function get$1(key, dict) {
  return Belt_MapString.get(dict, key);
}

function insert(key, value, dict) {
  return Belt_MapString.set(dict, key, value);
}

function keys(m) {
  return Belt_List.fromArray(Belt_MapString.keysToArray(m));
}

function update(key, f, dict) {
  return Belt_MapString.update(dict, key, f);
}

var map$4 = Belt_MapString.map;

function toString$1(d) {
  var l = Belt_MapString.toList(d);
  var l$1 = Belt_List.map(l, (function (param) {
          return "\"" + (param[0] + ("\": \"" + (String(param[1]) + "\"")));
        }));
  var s = $$String.concat(", ", l$1);
  return "{" + (s + "}");
}

function pp$3(valueFormatter, fmt, map) {
  Format.pp_print_string(fmt, "{ ");
  Belt_MapString.forEach(map, (function (k, v) {
          Format.pp_print_string(fmt, k);
          Format.pp_print_string(fmt, ": ");
          Curry._2(valueFormatter, fmt, v);
          return Format.pp_print_string(fmt, ",  ");
        }));
  Format.pp_print_string(fmt, "}");
  return /* () */0;
}

function merge(f, dict1, dict2) {
  return Belt_MapString.merge(dict1, dict2, f);
}

function fromList$5(l) {
  return Belt_MapInt.fromArray(Belt_List.toArray(l));
}

function get$2(key, dict) {
  return Belt_MapInt.get(dict, key);
}

function insert$1(key, value, dict) {
  return Belt_MapInt.set(dict, key, value);
}

function update$1(key, f, dict) {
  return Belt_MapInt.update(dict, key, f);
}

function keys$1(m) {
  return Belt_List.fromArray(Belt_MapInt.keysToArray(m));
}

var map$5 = Belt_MapInt.map;

function toString$2(d) {
  var l = Belt_MapInt.toList(d);
  var l$1 = Belt_List.map(l, (function (param) {
          return "\"" + (String(param[0]) + ("\": \"" + (String(param[1]) + "\"")));
        }));
  var s = $$String.concat(", ", l$1);
  return "{" + (s + "}");
}

function pp$4(valueFormatter, fmt, map) {
  Format.pp_print_string(fmt, "{ ");
  Belt_MapInt.forEach(map, (function (k, v) {
          Format.pp_print_int(fmt, k);
          Format.pp_print_string(fmt, ": ");
          Curry._2(valueFormatter, fmt, v);
          return Format.pp_print_string(fmt, ",  ");
        }));
  Format.pp_print_string(fmt, "}");
  return /* () */0;
}

function merge$1(f, dict1, dict2) {
  return Belt_MapInt.merge(dict1, dict2, f);
}

function regex(s) {
  return new RegExp(s, "g");
}

function contains$1(re, s) {
  return re.test(s);
}

function replace(re, repl, str) {
  return str.replace(re, repl);
}

function matches(re, s) {
  return Caml_option.null_to_opt(re.exec(s));
}

var Regex = /* module */Block.localModule([
    "regex",
    "contains",
    "replace",
    "matches"
  ], [
    regex,
    contains$1,
    replace,
    matches
  ]);

var List$1 = [
  Belt_List.flatten,
  sum$1,
  floatSum$1,
  floatSum$1,
  map$1,
  indexedMap,
  indexedMap,
  indexedMap,
  map2$1,
  getBy,
  getBy,
  find$1,
  elemIndex,
  elemIndex,
  last,
  member,
  uniqueBy,
  uniqueBy,
  getAt,
  getAt,
  any$1,
  head,
  drop,
  init,
  filterMap,
  filterMap,
  filter$1,
  concat,
  partition,
  foldr,
  foldl,
  findIndex,
  findIndex,
  take,
  updateAt,
  updateAt,
  length$1,
  reverse$1,
  dropWhile,
  dropWhile,
  isEmpty$1,
  isEmpty$1,
  cons,
  takeWhile,
  takeWhile,
  all$1,
  tail,
  append$1,
  removeAt,
  removeAt,
  minimumBy,
  minimumBy,
  minimum,
  maximumBy,
  maximumBy,
  maximum,
  sortBy,
  sortBy,
  span,
  groupWhile,
  groupWhile,
  splitAt,
  splitAt,
  insertAt,
  insertAt,
  splitWhen,
  splitWhen,
  intersperse$1,
  initialize$1,
  sortWith,
  sortWith,
  iter
];

var IntSet = [
  fromList$3,
  fromList$3,
  member$2,
  diff$1,
  isEmpty$3,
  isEmpty$3,
  toList$6,
  toList$6,
  ofList$1,
  ofList$1,
  Belt_SetInt.union,
  remove$1,
  add$1,
  set$2,
  member$2,
  Belt_SetInt.empty,
  pp$2
];

var StrSet = [
  fromList$2,
  fromList$2,
  member$1,
  diff,
  isEmpty$2,
  isEmpty$2,
  toList$5,
  toList$5,
  ofList,
  ofList,
  Belt_SetString.union,
  remove,
  add,
  set$1,
  member$1,
  Belt_SetString.empty,
  pp$1
];

var StrDict = [
  Belt_MapString.toList,
  Belt_MapString.toList,
  Belt_MapString.empty,
  fromList$4,
  fromList$4,
  get$1,
  insert,
  keys,
  update,
  map$4,
  toString$1,
  toString$1,
  pp$3,
  merge
];

var IntDict = [
  Belt_MapInt.toList,
  Belt_MapInt.toList,
  Belt_MapInt.empty,
  fromList$5,
  fromList$5,
  get$2,
  insert$1,
  update$1,
  keys$1,
  map$5,
  toString$2,
  toString$2,
  pp$4,
  merge$1
];

exports.$less$pipe = $less$pipe;
exports.$great$great = $great$great;
exports.$less$less = $less$less;
exports.identity = identity;
exports.$$Array = $$Array;
exports.List = List$1;
exports.Result = Result;
exports.$$Option = $$Option;
exports.Char = Char$1;
exports.Int = Int;
exports.Tuple2 = Tuple2;
exports.Tuple3 = Tuple3;
exports.$$String = $$String$1;
exports.IntSet = IntSet;
exports.StrSet = StrSet;
exports.StrDict = StrDict;
exports.IntDict = IntDict;
exports.Regex = Regex;
/* Format Not a pure module */
